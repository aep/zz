using async;
using time;
using string;
using err;
using log;

using <stdio.h>::{perror, fprintf, stderr, printf};
using <assert.h>::{assert};
using <windows.h> as windows;

export fn main() -> int {

    new+1000 e = err::make();
    new+1000 driver = async::system();

    new i = async::stdin(&e, &driver);
    e.abort();

    fprintf(stderr, "timeout will happen after 1 seconds, then every 3 second.\ninterval must remain uneffected from stdin input\n\n");


    new t = async::tick(&driver, time::from_seconds(1));
    e.abort();


    bool mut is_3_second = false;
    let mut last_wakeup  = time::tick();

    for (;;) {
        log::info(".");

        string::String+2 mut buf;
        buf.clear();

        switch i.read_string(&e, &buf) {
            async::Result::Ready => {
                printf(">%s<\n", buf.mem);
            }
            async::Result::Later => {}
            async::Result::Eof => {
                i.close(&e);
                e.abort();
                return 0;
            }
            async::Result::Error => {
                e.abort();
            }
        }
        e.abort();

        if t.expired() {
            let now = time::tick();
            fprintf(stderr, "tick after %u ms\n", now.to_millis() - last_wakeup.to_millis());
            last_wakeup = now;

            if !is_3_second {
                async::tick(&t, &driver, time::from_seconds(3));
            }
        }

        driver.wait(&e);
        e.abort();
    }
    return 0;

}

