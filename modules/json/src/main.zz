using log;
using json;
using pool;
using err;
using buffer;
using mem;
using slice;
using vec;
using map;
using vec;


enum FuelType @json::des::impl()
{
    Invalid,
    StinkyGoo,
    Electric,
}

struct Engine @json::des::impl()
{
    FuelType    fuel_type;
    bool        running;
}

struct Window  @json::des::impl()
{
    bool open;
}

struct Person @json::des::impl()
{
    u64 seat;
}

type WindowList @json::des::impl() = vec::Vec[vec::item = Window];
type IntList    @json::des::impl() = vec::Vec[vec::item = u64];
type PeopleMap  @json::des::impl() = map::Map[map::key  = char, map::val = Person];

struct Car @json::des::impl()
{
    int         tires;
    char*       brand;
    Engine      engine;
    Window*     sunroof;
    WindowList  windows;
    IntList     ints;
    PeopleMap   people;
}


export fn from_json(Car mut new * self, err::Err+et mut *e, char *js, pool::Pool mut* pt)
    where err::checked(*e)
    where nullterm(js)
{
    mem::zero(self);
    json::U u = @json::des::use(Car, self, pt);
    static_attest(safe(u.it));
    new+1000 p = json::parser(e, u);
    if err::check(e) { return ; }
    json::push(&p, e, js, buffer::strlen(js));
}

pub fn main() {
    new+1000  e = err::make();

    new+10000 p = pool::make(32);
    new car = from_json(&e, r#"{
        "tires": 3,
        "brand": "We Hate The Environment Inc.",
        "wut": 1,
        "engine": {
            "fuel_type": "Electric",
            "running":true
        },
        "sunroof": {
            "open": true
        },
        "windows": [
            {
                "open": true
            },
            {
                "open": false
            },
            {
                "open": true
            },
        ],
        "ints": [1,2,3,4,4,5,6,7,7],
        "people": {
            "mum" :     { "seat": 1},
            "the cat":      { "seat": 2},
        }
    }"#, &p);
    e.abort();


    log::info("car.brand = %s", car.brand);
    log::info("car.tires = %d", car.tires);
    log::info("car.engine.running = %d", car.engine.running);
    log::info("car.engine.fuel_type = %d", car.engine.fuel_type);
    if car.sunroof != 0 {
        static_attest(safe(car.sunroof));
        log::info("car.sunroof.open = %d", car.sunroof->open);
    }
    for let mut iter = vec::iter(&car.windows); iter.next(); {
        let window = (Window *)iter.val.mem;
        err::assert_safe(window);
        log::info("car.windows[].open = %d", window->open);
    }
    for let mut iter = vec::iter(&car.ints); iter.next(); {
        u64 v = unsafe<u64>(*(u64 *)iter.val.mem);
        log::info("car.ints[] = %d", v);
    }
    for let mut iter = map::keys(&car.people); iter.next(); {
        Person *v = (Person*)map::get(&car.people, iter.key.mem, iter.key.size);
        err::assert_safe(v);
        log::info("car.people[%s].seat = %d", iter.key.mem, v->seat);
    }
}
