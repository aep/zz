using err;
using vec;
using slice;
using parser;
using json;
using pool;
using buffer;

using <stdio.h>::{stdin, stderr, fprintf, printf};

//  {"args":[{"Literal":{"loc":{"file":"/Users/aep/proj/zz/tests/mustpass/procmacro/src/main.zz"},"v":"3"}}]}


export enum ExpressionType {
    Invalid,
    Literal,
    LiteralString,
    Name,
    Infix,
    Call,
}

export union ExpressionValue {
    slice::slice::Slice     string;
    InfixExpression         infix;
    CallExpression          call;
}

export struct Expression
{
    ExpressionType  t;
    ExpressionValue v;
}
export fn make_expression(Expression mut new*self, pool::Pool mut*p) {
}

export enum InfixOperator {
    Invalid,
    Equals,
    Nequals,
    Add,
    Subtract,
    Multiply,
    Divide,
    Bitxor,
    Booland,
    Boolor,
    Moreeq,
    Lesseq,
    Lessthan,
    Morethan,
    Shiftleft,
    Shiftright,
    Modulo,
    Bitand,
    Bitor,
}

export struct InfixExpression {
    Expression mut*lhs;
    Expression mut*rhs;
    InfixOperator op;
}
export fn make_infix_expression(InfixExpression mut new*self, pool::Pool mut*p) {
    self->op = InfixOperator::Invalid;
}

export struct CallExpression {
    Expression mut*name;
    vec::Vec[vec::item = Expression,+0] mut args;
}
export fn make_call_expression(CallExpression mut new*self, pool::Pool mut*p) {
}


export enum DefType {
    Invalid,
    Struct,
    Enum,
    Type,
}

export union DefValue {
    DefStruct   dstruct;
    DefEnum     denum;
    DefAlias    dalias;
}


export enum TailType {
    None,
    Dynamic,
    Static,
    Bind,
}

export struct Tail {
    TailType t;
}

export struct Typed {
    char *      name;
    Tail        tail;
    vec::Vec+0  mut ptr;
    vec::Vec[vec::item = Expression,+0]  mut params;
}

export fn make_typed(Typed mut new*self, pool::Pool mut*p) {
    self->name = 0;
    self->ptr.make_with_pool(p);
    self->params.make_with_pool(p);
}

export enum ArrayType {
    None,
    Unsized,
    Sized,
}

export struct Array {
    ArrayType t;
}

export struct Field {
    char * name;
    Typed typed;
    Array array;
}

export fn make_field(Field mut new*self, pool::Pool mut*p) {
    self->name = 0;
    self->typed.make_typed(p);
}

export struct DefStruct {
    vec::Vec+0 mut fields;
}
export fn make_def_struct(DefStruct mut new*self, pool::Pool mut*p) {
    self->fields.make_with_pool(p);
}

export struct EnumItem  {
    char * name;
}

export struct DefEnum {
    vec::Vec+0 mut items;
}
export fn make_def_enum(DefEnum mut new*self, pool::Pool mut*p) {
    self->items.make_with_pool(p);
}

export struct DefAlias{
    Typed alias;
}
export fn make_def_alias(DefAlias mut new*self, pool::Pool mut*p) {
    self->alias.make_typed(p);
}


export struct Local
{
    DefType     t;
    DefValue    v;
    char*   name;
}

export struct Ast+
{
    vec::Vec+0      mut args;
    Local           mut local;
    pool::Pool+     mut pl;
}

pub fn from_macro(Ast+t mut new *self)
    where t > t/64
    model(vec::integrity(&self->args))
{
    self->pl.make(64);
    self->args.make_with_pool(&self->pl);
    new+1000 e = err::make();
    new+1000 p = json::parser(&e, json::U{
        it: parser::parse_doc,
        user1: self,
        user2: &self->pl,
    });
    e.abort();

    new+1000 s = buffer::make();
    for (; s.fgets(stdin) ; s.clear()) {
        json::push(&p, &e, s.mem, s.at);
        e.abort();
    }
    static_attest(vec::integrity(&self->args));
}

