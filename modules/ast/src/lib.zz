using err;
using json;
using buffer;
using pool;

using <stdio.h>::{stdin, stderr, fprintf, printf};
using <string.h>::{strdup, memcpy};

export symbol ParseError;


//  {"args":[{"Literal":{"loc":{"file":"/Users/aep/proj/zz/tests/mustpass/procmacro/src/main.zz"},"v":"3"}}]}



fn parse_v(json::U *u, err::Err+et mut *e, json::Parser+pt mut* p, char *k, json::Value v)
    where err::checked(*e)
    where nullterm(k)
{
    let arg = (ExpressionS mut*)u->user1;
    static_attest(safe(arg));

    if buffer::cstr_eq(k, "v") {
        switch v.t {
            json::ValueType::String => {
                static_attest(safe(arg->pool));
                static_attest(safe(v.string));
                static_attest(nullterm(v.string));
                char mut * dup = arg->pool->malloc(buffer::strlen(v.string));
                memcpy(dup, v.string, buffer::strlen(v.string) + 1);
                arg->v.string = dup;
            }
            default => {
            }
        }
    }
}

fn parse_t(json::U *u, err::Err+et mut *e, json::Parser+pt mut* p, char *k, json::Value v)
    where err::checked(*e)
    where nullterm(k)
{
    let arg = (ExpressionS mut*)u->user1;
    static_attest(safe(arg));

    if buffer::cstr_eq(k, "t") {
        switch v.t {
            json::ValueType::Object => {
              json::next(p,  e, json::U{ it: parse_t_other, user1: (void mut*)arg} );
              if err::check(e) {
                return;
              }
            }
            default => {
            }
        }
    }
}

fn parse_t_other(json::U *u, err::Err+et mut *e, json::Parser+pt mut* p, char *k, json::Value v)
    where err::checked(*e)
    where nullterm(k)
{
    let arg = (ExpressionS mut*)u->user1;
    static_attest(safe(arg));

    if buffer::cstr_eq(k, "Other") {
        switch v.t {
            json::ValueType::Array => {
              json::next(p,  e, json::U{ it: parse_t_other_value, user1: (void mut*)arg} );
              if err::check(e) {
                return;
              }
            }
            default => {
            }
        }
    }
}

fn parse_t_other_value(json::U *u, err::Err+et mut *e, json::Parser+pt mut* p, char *k, json::Value v)
    where err::checked(*e)
    where nullterm(k)
{
  let arg = (ExpressionS mut*)u->user1;
  static_attest(safe(arg));

  switch v.t {
    json::ValueType::String => {
      static_attest(safe(arg->pool));
      static_attest(safe(v.string));
      static_attest(nullterm(v.string));
      char mut * dup = arg->pool->malloc(buffer::strlen(v.string));
      memcpy(dup, v.string, buffer::strlen(v.string) + 1);
      arg->v.string = dup;
    }
    default => {
    }
  }
}

fn parse_arg(json::U *u,  err::Err+et mut *e, json::Parser+pt mut* p, char *k, json::Value v)
    where err::checked(*e)
    where nullterm(k)
{
    let arg = (ExpressionS mut*)u->user1;
    static_attest(safe(arg));

    switch v.t {
        json::ValueType::Object => {
            if buffer::cstr_eq(k, "Literal") {
                arg->t = Expression::Literal;
                json::next(p,  e, json::U{it:parse_v, user1: (void mut*)arg} );
                if err::check(e) {
                    return;
                }
            } else if buffer::cstr_eq(k, "LiteralString") {
                arg->t = Expression::LiteralString;
                json::next(p,  e, json::U{it:parse_v, user1: (void mut*)arg} );
                if err::check(e) {
                    return;
                }
            } else if buffer::cstr_eq(k, "Name") {
                arg->t = Expression::Name;
                json::next(p,  e, json::U{it:parse_t, user1: (void mut*)arg} );
                if err::check(e) {
                    return;
                }
            } else if buffer::cstr_eq(k, "args") {
                json::next(p,  e, json::U{it:parse_arg, user1: (void mut*)arg} );
                if err::check(e) {
                    return;
                }
            } else {
                err::fail(e, ParseError, "got %s expected Literal | LiteralString", k);
            }
        }
        default => {
            err::fail(e, ParseError, "got %s expected Literal | LiteralString ", k);
        }
    }
}


fn parse_arglist(json::U *u,  err::Err+et mut *e, json::Parser+pt mut* p, char *k, json::Value v)
    where err::checked(*e)
    where nullterm(k)
{
    let ast = (Ast mut*)u->user1;
    static_attest(safe(ast));

    switch v.t {
        json::ValueType::Object => {
            err::assert(v.index < static(len(ast->args)));
            ast->args[v.index].pool = &ast->pool;
            json::next(p,  e, json::U { it: parse_arg, user1: (void mut*)&ast->args[v.index]} );
            if err::check(e) {
                return;
            }
        }
        default => {
            err::fail(e, ParseError, "got %s expected arg object", k);
        }
    }
}

fn parse_doc(json::U *u,  err::Err+et mut *e, json::Parser+pt mut* p, char *k, json::Value v)
    where err::checked(*e)
    where nullterm(k)
{
    let ast = (Ast mut*)u->user1;
    static_attest(safe(ast));

    switch v.t {
        json::ValueType::Array => {
            if buffer::cstr_eq(k, "args") {
                json::next(p,  e, json::U{ it: parse_arglist, user1: ast} );
                if err::check(e) {
                    return;
                }
            } else {
                err::fail(e, ParseError, "got %s expected args ", k);
            }
        }
        default => {
            err::fail(e, ParseError, "got %s expected args ", k);
        }
    }
}


export enum Expression
{
    Invalid,
    Literal,
    LiteralString,
    Name,
}

export union ExpressionValue {
    char * string;
}

export struct ExpressionS
{
    Expression      t;
    ExpressionValue v;
    pool::Pool mut* pool;
}

export struct Ast+
{
    ExpressionS     args[100];
    pool::Pool+     mut pool;
}

pub fn from_macro(Ast+t mut new *self)
    where t > t/64
{
    self->pool.make(64);
    new+1000 e = err::make();
    new+1000 parser = json::parser(&e, json::U{ it: parse_doc, user1: self} );
    e.abort();

    new+1000 s = buffer::make();
    for (; s.fgets(stdin) ; s.clear()) {
        json::push(&parser, &e, s.mem, s.at);
        e.abort();
    }
}

